//
// Copyright 2019 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

import Foundation

extension DocumentationDatabase {
    
    /// Patches all repositories where the documentation is composed from single file. This typically
    /// means that "_Sidebar.md" file has to be created in the repository directory.
    ///
    /// - Returns: true if operation succeeded
    func patchSingleFileDocumentation() -> Bool {
        Console.info("Patching single docs...")
        repositories.forEach { repoId, repo in
            if repoId.contains("/") {
                return
            }
            if repo.params.hasSingleDocument {
                self.patchSingleFileRepo(repoId: repoId, repo: repo)
            }
        }
        return true
    }
    
    /// Patches repository where the documentation is composed from single file.
    ///
    /// - Parameters:
    ///   - repoId: repository identifier
    ///   - repo: RepositoryContent object
    private func patchSingleFileRepo(repoId: String, repo: RepositoryContent) {
        
        let fullIndexFile = repoId.addingPathComponent(effectiveGlobalParameters.targetHomeFile!)
        guard let document = findDocumentationItem(path: fullIndexFile)?.document else {
            Console.fatalError("Counld not find `\(fullIndexFile)` in database.")
        }
        var lines: [String]
        if let toc = document.firstMetadata(withName: "TOC") {
            lines = prepareSidebarContentFromTOC(document: document, toc: toc)
        } else {
            lines = prepareSidebarContentFromHeaders(document: document)
        }
        lines.insert(contentsOf: [
            "<!-- ",
            "   This file was autogenerated by DocuCheck utility.",
            "            Do not manually edit this file.",
            " -->",
            ""
            ], at: 0)
        
        let indexFile = effectiveGlobalParameters.targetHomeFile!
        let sidebarFile = "_Sidebar.md"
        let sidebarFullPath = repo.fullRepositoryPath.addingPathComponent(sidebarFile)
        let sidebarDocName = repoId.addingPathComponent(sidebarFile)
        
        let sidebarSource = StringDocument(name: sidebarDocName, string: "", fileName: sidebarFullPath)
        let sidebar = MarkdownDocument(source: sidebarSource, repoIdentifier: repoId)
        
        sidebar.add(lines: lines, at: 0)
        sidebar.referenceCount += 1
        
        // Patch links
        sidebar.allLinks.forEach { link in
            if link.path.hasPrefix("#") {
                link.path = indexFile + link.path
            }
        }
        
        add(item: sidebar, intoRepo: repo)
    }
    
    private func prepareSidebarContentFromHeaders(document: MarkdownDocument) -> [String] {
        var lines = [String]()
        document.allHeaders.forEach { header in
            let level = header.level
            if level == 2 {
                let padding = String(repeating: "   ", count: level - 2)
                let title = header.title
                let link  = header.anchorName
                let line  = "\(padding)- [\(title)](#\(link))"
                lines.append(line)
            }
        }
        if lines.isEmpty {
            Console.warning(document, "There are no headers in the document, so sidebar will be empty.")
        }
        return lines
    }
    
    private func prepareSidebarContentFromTOC(document: MarkdownDocument, toc: MarkdownMetadata) -> [String] {
        guard let lines = document.getLinesForMetadata(metadata: toc, includeMarkers: true, removeLines: true) else {
            Console.error(document, "Unable to get TOC section from the document.")
            Console.onExit()
        }
        return lines.map { $0.toString() }
    }
}
